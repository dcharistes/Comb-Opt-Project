import sys
import pyomo.environ as pyo
from pyomo.environ import Set, Param, Var, Objective, Constraint, Binary, NonNegativeReals, minimize, inequality

def read_data_gvrp(filename="gvrp_instance.txt"):
    """
    Read GVRP instance generated by gvrppgenerator.py

    File format from generator:
    Line 1: grid_size*grid_size V num_clusters K Q
    Line 2: num_clusters Clusters:
    Lines 3+: cluster_id x y demand (one per node in clusters)
    Line N: num_arcs Arcs:
    Lines N+1+: x1 y1 x2 y2 distance (one per arc)

    Returns:
        N: Total number of nodes (grid_size*grid_size)
        K: Number of vehicles
        Q: Vehicle capacity
        M: Number of clusters
        q_cluster: List of cluster demands [q_0, q_1, ..., q_M]
        a: List of cluster assignments [a_0, a_1, ..., a_N] where a[i] = cluster of node i
        costs: N x N cost matrix
    """

    with open(filename, "r") as f:
        lines = f.readlines()

    lines = [line.strip() for line in lines if line.strip()]

    # --- Line 1: Parse header ---
    header = lines[0].split()
    N = int(header[0])              # nodes (grid_size * grid_size)
    V = int(header[1])              # customers
    M = int(header[2])              # clusters
    K = int(header[3])              # vehicles
    Q = float(header[4])            # vehicle capacity

    # node i maps to coordinate (x, y), where node_index = x * sqrt(N) + y
    node_coords = {}                # {node_id: (x, y)}
    a = [0] * N                     # cluster of node i
    q_cluster = [0] * (M + 1)       # demand of cluster k (0-indexed)
    cluster_nodes = {}              # {cluster_id: [list of nodes]}

    # parse cluster information
    line_idx = 1

    # skip "M Clusters:" line
    if "Clusters:" in lines[line_idx]:
        line_idx += 1

    # read all cluster information
    while line_idx < len(lines) and "Arcs:" not in lines[line_idx]:
        parts = lines[line_idx].split()

        cluster_id = int(parts[0])

        x = int(parts[1])
        y = int(parts[2])
        demand = float(parts[3])

        # grid coordinates -> node id
        # node_id = x * sqrt(N) + y (check mapping func!)
        node_id = x * int(N**0.5) + y if int(N**0.5)**2 == N else None

        node_coords[node_id] = (x, y)
        a[node_id] = cluster_id

        if cluster_id not in cluster_nodes:
            cluster_nodes[cluster_id] = []

        cluster_nodes[cluster_id].append(node_id)

        # cluster demand
        # all nodes in same cluster have same demand value
        q_cluster[cluster_id] = demand

        line_idx += 1

    # parse arc information to build cost matrix
    cost_matrix = [[float('inf')] * N for _ in range(N)]

    # diagonal is set to 0
    for i in range(N):
        cost_matrix[i][i] = 0

    # ignore "num_arcs Arcs:" line
    if line_idx < len(lines) and "Arcs:" in lines[line_idx]:
        line_idx += 1

    # read all arcs and import the cost to the cost_matrix
    while line_idx < len(lines):
        parts = lines[line_idx].split()

        x1 = int(parts[0])
        y1 = int(parts[1])
        x2 = int(parts[2])
        y2 = int(parts[3])
        distance = float(parts[4])

        # Recover node IDs from coordinates
        grid_width = int(N**0.5)
        node_i = x1 * grid_width + y1
        node_j = x2 * grid_width + y2

        if node_i < N and node_j < N:
            cost_matrix[node_i][node_j] = distance

        line_idx += 1


    print(f"Successfully read GVRP instance:")
    print(f"  N (total nodes): {N}")
    print(f"  K (vehicles): {K}")
    print(f"  Q (capacity): {Q}")
    print(f"  M (clusters): {M}")
    print(f"  Cluster demands: {q_cluster}")
    print(f"  Nodes per cluster: {cluster_nodes}")

    return N, K, Q, M, q_cluster, a, cost_matrix


def build_gvrp_model(N, K, Q, M, q_cluster, a, costs):

    # 1. process data
    V_set = range(N)
    A_set = [(i, j) for i in V_set for j in V_set if i != j] # set of arcs

    a_param = {i: a[i] for i in V_set}
    c_param = {(i, j): costs[i][j] for i, j in A_set} #costs
    q_param = {i: q_cluster[i] for i in V_set} # demand of each cluster. maybe not in V_set. V_set is for all the nodes. we need the clusters here!

    # 2. model init
    model = pyo.ConcreteModel()

    # 3. sets
    # V: set of vertices (0 is depot)
    model.V = Set(initialize=V_set, doc="Set of all nodes (0 is depot)")
    # V_cust: set of customer vertices (without depot)
    model.V_cust = Set(initialize=[i for i in V_set if i != 0])
    # A: set of arcs
    model.A = Set(within=model.V * model.V, initialize=A_set)

    # 4. params
    # c[i, j]: cost of arc (i, j)
    model.c = Param(model.A, initialize=c_param)
    # a(i): the cluster index of vertex i
    model.a = Param(model.V, initialize=a_param)
    # q[a(i)]: demand of cluster a(i) that the i node is in it.
    model.q_cluster = Param(initialize=q_param)
    # Q: vehicle capacity
    model.Q = Param(initialize=Q)
    # K: number of available vehicles
    model.K = Param(initialize=K)

    # 5. vars
    # x[i, j]: binary variable -> 1 if arc (i, j) is traversed, 0 otherwise
    model.x = pyo.Var(model.A, domain=pyo.Binary)
    # f[i, j]: amount of commodity flow (load) carried on arc (i, j)
    model.f = pyo.Var(model.A, domain=pyo.NonNegativeReals)

    # 6. obj func (minimize total cost)
    def obj_rule(model):
        # (1) in the paper (Minimize sum(c_ij * x_ij))
        return sum(model.c[i, j] * model.x[i, j] for (i, j) in model.A)
    model.obj = pyo.Objective(rule=obj_rule, sense=pyo.minimize)

    # 7. constraints

    # 7.1. each customer has a exactly one emtering arc (Equivalent to x(δ-(Ck)) = 1)
    def visit_in_rule(model, i):
        return sum(model.x[j,i] for j in model.V if (j,i) in model.A) == 1
    model.visit_in = pyo.Constraint(model.V_cust, rule=visit_in_rule, doc='customer is entered once')

    # 7.2. each customer has a exactly one leaving arc (x(δ+(Ck)) = 1)
    def visit_out_rule(model, i):
        return sum(model.x[i,j] for j in model.V if (i,j) in model.A) == 1
    model.visit_out = pyo.Constraint(model.V_cust, rule=visit_out_rule, doc='customer is left once')

    # 7.3. exactly K vehicles depart from the depot (Equivalent to x(δ+(C0)) = K)
    def depot_out_rule(model):
        return sum(model.x[0,j] for j in model.V_cust if (0,j) in model.A) == model.K
    model.depot_out = pyo.Constraint(rule=depot_out_rule, doc='K vehicles depart depot')

    # 7.4. route continuity
    # constraint 5 in the paper: x(δ+(i)) = x(δ-(i))
    def flow_conservation_rule(model, i):
        sum_out = sum(model.x[i,j] for j in model.V if (i,j) in model.A)
        sum_in = sum(model.x[j,i] for j in model.V if (j,i) in model.A)
        return sum_out == sum_in
    model.flow_conservation = pyo.Constraint(model.V, rule=flow_conservation_rule, doc='assignment flow conservation')

    # 7.5. flow blance (Commodity Flow)
    # constraint (6) in the paper for i in V\{0} without depot

    # flow balance -> q[a(i)] is the cluster demand of node i:
    def flow_balance_rule(model, i):
        if i == 0:
            return Constraint.Skip  # depot has no demand

        sum_f_out = sum(model.f[i,j] for j in model.V if (i,j) in model.A)
        sum_f_in = sum(model.f[j,i] for j in model.V if (j,i) in model.A)

        # term (sum(x_ji) + sum(x_ij)) is 2 for a visited customer node
        sum_x_in = sum(model.x[j,i] for j in model.V if (j,i) in model.A)
        sum_x_out = sum(model.x[i,j] for j in model.V if (i,j) in model.A)

        # constraint: flow and assignment link. ensures the commodity (demand) is dropped
        lhs = sum_f_out - sum_f_in
        cluster_i = model.a[i]
        rhs = 0.5 * model.q_cluster[cluster_i] * (sum_x_in + sum_x_out)
        return lhs == rhs
    model.flow_balance = pyo.Constraint(model.V_cust, rule=flow_balance_rule, doc='commodity flow balance at customer nodes')

    # 7.6. capacity constraints
    # strengthened bound 9 from the paper:

    # capacity lower bound -> flow of arc i,j >= the cluster demand of the node i. if the arc ij, is used
    def capacity_lower_rule(model, i, j):
        if i == j:
            return pyo.Constraint().Skip()

        cluster_i = model.a[i]
        return model.f[i,j] >= model.q_cluster[cluster_i] * model.x[i,j]

    model.capacity_lower = pyo.Constraint(model.A, rule=capacity_lower_rule, doc='flow must carry at least the starting node demand')

    # capacity upper bound -> (flow_ij) <=  (vehicle capacity) - (the cluster demand of node j)
    def capacity_upper_rule(model, i, j):
        if i == j:
            return pyo.Constraint.Skip

        cluster_j = model.a[j]
        return model.f[i,j] <= (model.Q - model.q_cluster[cluster_j]) * model.x[i,j]

    model.capacity_upper = pyo.Constraint(model.A, rule=capacity_upper_rule, doc='flow must respect remaining vehicle capacity')

    return model


# solve the generator's random instances
if __name__ == "__main__":
    # Read instance from generator output
    instance_filename = "gvrp_instance.txt"

    try:
        N, K, Q, M, q_cluster, a, cost_matrix = read_data_gvrp(instance_filename)

        # Build model
        model = build_gvrp_model(N, K, Q, M, q_cluster, a, cost_matrix)

        print("\n----- Model created successfully -----")
        print(f"Model has {len(model.A)} arcs, {len(model.V_cust)} customers, {M} clusters")

        # Solve model
        solver = pyo.SolverFactory("gurobi")

        print("\n----- Solving model -----")
        result = solver.solve(model, tee=True)

        print("\n----- Solution -----")
        print(result)

        if result.solver.status == 'ok':
            print(f"\nOptimal objective value: {pyo.value(model.obj)}")

            # Display solution
            print("\n--- Arcs used in solution ---")
            for (i, j) in model.A:
                if pyo.value(model.x[i, j]) > 0.5:
                    flow = pyo.value(model.f[i, j])
                    print(f"Arc ({i}, {j}): flow = {flow:.2f}")

    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()

